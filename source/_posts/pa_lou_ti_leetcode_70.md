---
title: 爬楼梯 Leetcode 70
date: 2020-07-27 10:19:35
categories: 算法
tags:
  - 算法
  - 动态规划
  - DP
  - 初级算法
---

# 讲解

爬楼梯也是一个简单的动态规划入门题目，解题思路和打家劫舍一样。

其实我们在面对这些题目的时候，更主要的就是取思考 **状态转移** 的方程怎么提取。

<!-- more -->

**每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？**

我们先根据题目设置**基底**就是 1 级台阶只有 1 种方法，2 级台阶有 2 种。

当到第 3 极台阶时可以把 3 拆分为 2 级台阶 + 1 级台阶，其爬楼梯方法等于 2 级 的 2 种 + 1 级的 1 种。

如果是 4 级台阶，可以拆分为 3 级台阶 + 2 级台阶 ，这里和 3 级有点区别，当我们看到 3 级的时候思考到了 2 + 1 = 3 ，但 3 + 2 并不等于 4 ，但为什么 4 又可以是 3 级加 2 级台阶呢？我们首先把 4 级的走法排列出来。

1. 1 + 1 + 1 + 1 = 4
2. 2 + 2 = 4
3. 1 + 1 + 2 = 4
4. 2 + 1 + 1 = 4
5. 1 + 2 + 1 = 4

足以证明，3 级能被 2 + 1 级台阶得出**解**是因为 2 和 1 是 n[i-1] + n[i-2] ，那么 4 能被 3 和 2 解，也是同理。
所以在此我们可以得出响应的**状态转移**方程 n[i] = n[i-1] + n[i-2]

# Golang 解题

```go
func climbStairs(n int) int {

    // 边界检查
    result := 0
    if n == 0 {
        return result
    }

    // 边界检查，如果是 1 或 2 直接return
    if (n == 1) {return 1}
    if (n == 2) {return 2}

    dp := make([]int,n)

    // 设置基底
    dp[0] = 1
    dp[1] = 2

    // 循环推算
    for i := 2; i < n ; i ++ {
        dp[i] = dp[i-1] + dp[i-2]
    }

    return dp[n-1]
}
```
